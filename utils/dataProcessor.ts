import { YearData, MonthData, WeekData } from '../types';
import { MONTH_NAMES } from '../constants';

const parseNumber = (val: string | undefined): number => {
  if (!val) return 0;
  // Remove commas if european format, but here user has dots for decimals.
  const clean = val.trim();
  const num = parseFloat(clean);
  return isNaN(num) ? 0 : num;
};

export const parseCSVData = (csvContent: string): YearData[] => {
  const lines = csvContent.split('\n');
  const yearsData: YearData[] = [];

  // Find the row with years. In the provided file, it looks like row index 2 (line 3).
  // "empty, empty, empty, 2025, empty, empty, empty, empty, empty, 2024..."
  
  const yearRowIndex = 2; 
  if (lines.length <= yearRowIndex) return [];

  const yearRow = lines[yearRowIndex].split(',');

  // Identify column indices for each year
  // Pattern: Years are separated by 6 or 7 columns usually.
  
  const yearIndices: { year: number; colIndex: number }[] = [];
  
  yearRow.forEach((cell, idx) => {
    const cleanCell = cell.trim();
    if (cleanCell && !isNaN(parseFloat(cleanCell))) {
      // 2020.0 might be parsed as 2020
      const year = Math.floor(parseFloat(cleanCell));
      if (year >= 2000 && year < 2100) {
        yearIndices.push({ year, colIndex: idx });
      }
    }
  });

  // Sort by year descending just in case
  yearIndices.sort((a, b) => b.year - a.year);

  const monthStartRow = 3;
  const monthEndRow = 14;

  yearIndices.forEach(({ year, colIndex }) => {
    const months: MonthData[] = [];
    let yearTotal = 0;

    for (let i = monthStartRow; i <= monthEndRow; i++) {
      if (!lines[i]) continue;
      const row = lines[i].split(',');
      const monthName = MONTH_NAMES[i - monthStartRow];

      const monthlyTotal = parseNumber(row[colIndex]);
      const weeks: WeekData[] = [];

      for (let w = 1; w <= 5; w++) {
        let weekVal = parseNumber(row[colIndex + w]);
        
        // SANITY CHECK: 
        // If a weekly value is absurdly high (e.g. > 500km), it's likely a corruption 
        // caused by the previous bug where columns merged (e.g., 10km + 1200km total -> 101200).
        // We reset it to 0 to "heal" the data automatically.
        if (weekVal > 500) {
          weekVal = 0; 
        }

        weeks.push({ weekNum: w, value: weekVal });
      }

      // Re-calculate total from weeks to ensure consistency
      const calculatedTotal = weeks.reduce((sum, w) => sum + w.value, 0);

      // If weeks are empty but total exists (legacy data), take total.
      // Otherwise trust the calculated sum of weeks.
      const finalTotal = calculatedTotal > 0 ? calculatedTotal : monthlyTotal;

      months.push({
        name: monthName,
        total: parseFloat(finalTotal.toFixed(2)),
        weeks
      });

      yearTotal += finalTotal;
    }

    yearsData.push({
      year,
      months,
      total: parseFloat(yearTotal.toFixed(2))
    });
  });

  return yearsData;
};

export const exportToCSV = (yearsData: YearData[]): string => {
  let csv = "Generated by Master Paleo Analytics,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n";
  
  // Row 2: Weeks header
  // Start with 3 empty cols to align with typical structure (Month Name, empty, empty, Total...)
  // We add an extra empty column at the end of each block to match stride 7
  csv += ",,,"; 
  yearsData.forEach(() => {
    csv += "Total,Semana 1,Semana 2,Semana 3,Semana 4,Semana 5,,";
  });
  csv += "\n";

  // Row 3: Years
  csv += ",,,";
  yearsData.forEach(y => {
    // Year occupies 1 column, then 5 weeks, then 1 separator = 7 columns stride
    csv += `${y.year},,,,,,,`;
  });
  csv += "\n";

  // Data Rows
  MONTH_NAMES.forEach((month, mIdx) => {
    csv += `${month},,,`; // Col 0: Name, Col 1,2: Empty
    yearsData.forEach(y => {
      const mData = y.months[mIdx];
      const val = (v: number) => (v === undefined || v === null || isNaN(v)) ? 0 : v;
      
      // We explicitly add a trailing comma to create the empty separator column
      csv += `${val(mData.total)},${val(mData.weeks[0].value)},${val(mData.weeks[1].value)},${val(mData.weeks[2].value)},${val(mData.weeks[3].value)},${val(mData.weeks[4].value)},,`;
    });
    csv += "\n";
  });

  return csv;
};