import { YearData, MonthData, WeekData } from '../types';
import { MONTH_NAMES } from '../constants';

const parseNumber = (val: string | undefined): number => {
  if (!val) return 0;
  // Remove commas if european format, but here user has dots for decimals.
  const clean = val.trim();
  const num = parseFloat(clean);
  return isNaN(num) ? 0 : num;
};

export const parseCSVData = (csvContent: string): YearData[] => {
  const lines = csvContent.split('\n');
  const yearsData: YearData[] = [];

  // Find the row with years. In the provided file, it looks like row index 2 (line 3).
  // "empty, empty, empty, 2025, empty, empty, empty, empty, empty, 2024..."
  // Note: CSV split logic can be tricky with simple split(',') if there are quotes, 
  // but looking at source, it is simple values.
  
  const yearRowIndex = 2; 
  if (lines.length <= yearRowIndex) return [];

  const yearRow = lines[yearRowIndex].split(',');

  // Identify column indices for each year
  // Pattern: Years are separated by 6 columns (Total + 5 weeks) typically.
  // 2025 at index 3 (csv col index, 0-based)? 
  // Let's verify based on user input: ",,,2025," -> split results in ["", "", "", "2025", ...]
  
  const yearIndices: { year: number; colIndex: number }[] = [];
  
  yearRow.forEach((cell, idx) => {
    const cleanCell = cell.trim();
    if (cleanCell && !isNaN(parseFloat(cleanCell))) {
      // 2020.0 might be parsed as 2020
      const year = Math.floor(parseFloat(cleanCell));
      if (year >= 2000 && year < 2100) {
        yearIndices.push({ year, colIndex: idx });
      }
    }
  });

  // Sort by year descending just in case
  yearIndices.sort((a, b) => b.year - a.year);

  // Now process month rows. usually Jan is row 3 (index 3) to Dec row 14 (index 14).
  // Based on input: 
  // Line 0: Unnamed...
  // Line 1: semana 1...
  // Line 2: 2025...
  // Line 3: enero...
  
  const monthStartRow = 3;
  const monthEndRow = 14;

  yearIndices.forEach(({ year, colIndex }) => {
    const months: MonthData[] = [];
    let yearTotal = 0;

    for (let i = monthStartRow; i <= monthEndRow; i++) {
      if (!lines[i]) continue;
      const row = lines[i].split(',');
      const monthName = MONTH_NAMES[i - monthStartRow];

      // Based on the pattern:
      // The "Year" column usually holds the monthly total (or the one right after it?)
      // Looking at input: "enero,,,88.68,17.97,7.1,26.91,36.7"
      // 2025 is at index 3 (in row 2).
      // Data for 2025 in "enero" row starts at index 3.
      // Index 3: 88.68 (Total)
      // Index 4: 17.97 (Week 1)
      // Index 5: 7.1 (Week 2)
      // Index 6: 26.91 (Week 3)
      // Index 7: 36.7 (Week 4)
      // Index 8: (Week 5)

      const monthlyTotal = parseNumber(row[colIndex]);
      const weeks: WeekData[] = [];

      for (let w = 1; w <= 5; w++) {
        const weekVal = parseNumber(row[colIndex + w]);
        weeks.push({ weekNum: w, value: weekVal });
      }

      // Re-calculate total from weeks to ensure consistency, 
      // or use the provided total? 
      // Sometimes manual spreadsheets have errors. Let's trust the "weeks" as truth for editing,
      // but initially read the total.
      // Actually, let's sum the weeks for internal consistency in the app.
      const calculatedTotal = weeks.reduce((sum, w) => sum + w.value, 0);

      // If there is a significant discrepancy, we might note it, but for a management app,
      // usually derived data (total) should come from base data (weeks).
      // However, if weeks are empty but total exists (legacy data), we take total.
      
      const finalTotal = calculatedTotal > 0 ? calculatedTotal : monthlyTotal;

      months.push({
        name: monthName,
        total: parseFloat(finalTotal.toFixed(2)),
        weeks
      });

      yearTotal += finalTotal;
    }

    yearsData.push({
      year,
      months,
      total: parseFloat(yearTotal.toFixed(2))
    });
  });

  return yearsData;
};

export const exportToCSV = (yearsData: YearData[]): string => {
  // We need to reconstruct the messy CSV format to allow the user to save it back
  // This is a simplified reconstruction that aims to preserve the structure recognizable by the parser
  
  // 1. Header rows
  let csv = "Generated by Master Paleo Analytics,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n";
  
  // Row 2: Weeks header (simplified)
  csv += ",,"; 
  yearsData.forEach(() => {
    csv += ",semana 1,semana 2,semana 3,semana 4,semana 5";
  });
  csv += "\n";

  // Row 3: Years
  csv += ",,";
  yearsData.forEach(y => {
    csv += `${y.year},,,,,`;
  });
  csv += "\n";

  // Data Rows
  MONTH_NAMES.forEach((month, mIdx) => {
    csv += `${month},,`;
    yearsData.forEach(y => {
      const mData = y.months[mIdx];
      // Total, W1, W2, W3, W4, W5
      // Helper to preserve 0 as '0' instead of blank
      const val = (v: number) => (v === undefined || v === null) ? '' : v;
      
      csv += `${mData.total},${val(mData.weeks[0].value)},${val(mData.weeks[1].value)},${val(mData.weeks[2].value)},${val(mData.weeks[3].value)},${val(mData.weeks[4].value)}`;
    });
    csv += "\n";
  });

  return csv;
};